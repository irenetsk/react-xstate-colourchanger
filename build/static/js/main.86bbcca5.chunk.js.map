{"version":3,"sources":["dmAppointmentPlus2.ts","index.tsx"],"names":["send","actions","cancel","say","text","_context","type","value","grammar","person","day","time","grammar2","a","b","count","commands","promptAndAsk","prompt","nomatch","help","initial","states","entry","on","ENDSPEECH","ask","delay","id","dmMachine","init","CLICK","welcome","RECOGNISED","target","assign","context","option","recResult","query","invoke","src","event","nluRequest","onDone","data","intent","name","console","log","onError","menu","cond","todo","timer","maxspeech","finalmaxspeech","appointment","mainappointment","MAXSPEECH","counter","hist","history","who","wholeday","confirmwholeday","confirmtime","confirmed","fetch","Request","proxyurl","method","headers","body","then","json","inspect","url","iframe","machine","Machine","dm","asrtts","idle","LISTEN","SPEAK","ttsAgenda","recognising","exit","ASRRESULT","progress","match","speaking","recLogResult","test","logIntent","nluData","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","result","listen","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","changeColour","document","background","ttsStart","effect","ttsCancel","current","onClick","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.86bbcca5.chunk.js","sourcesContent":["import { MachineConfig, Machine, Action, actions, assign } from \"xstate\";\nimport \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nconst { send, cancel } = actions;\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nconst grammar: { [index: string]: { person?: string, day?: string, time?: string } \n} = {\n    \"John\": { person: \"John Appleseed\" },\n    \"Mary\": { person: \"Mary Curie\" },\n    \"George\": { person: \"George Smith\" },\n    \"Axel\": { person: \"Axel Rose\" },\n    \"Sebastian\": { person: \"Sebastian Bach\" },\n\n    \"on Monday\": { day: \"Monday\" },\n    \"on Tuesday\": { day: \"Tuesday\" },\n    \"on Wednesday\": { day: \"Wednesday\" },\n    \"on Thursday\": { day: \"Thursday\" },\n    \"on Friday\": { day: \"Friday\" },\n    \"on Saturday\": { day: \"Saturday\" },\n    \"on Sunday\": { day: \"Sunday\" },\n\n    \"at 5\": { time: \"5:00\" },\n    \"at 6\": { time: \"6:00\" },\n    \"at 7\": { time: \"7:00\" },\n    \"at 8\": { time: \"8:00\" },\n    \"at 9\": { time: \"9:00\" },\n    \"at 10\": { time: \"10:00\" },\n    \"at 11\": { time: \"11:00\" },\n    \"at 12\": { time: \"12:00\" }\n}\n\nconst grammar2: { [index: string]: boolean } = {\n    \"yes of course\": true,\n    \"sure\": true,\n    \"absolutely\": true,\n    \"yes\": true,\n    \"no way\": false,\n    \"no\": false\n}\n\nlet a = grammar2[\"yes\"];\nlet b = grammar2[\"no\"];\nlet count = 0;\nconst commands = { \"stop\":\"S\", \"help\":\"S\" };\n\nfunction promptAndAsk1(prompt: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: say(prompt),\n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: send('LISTEN')\n            },\n        }})\n}\n\nfunction promptAndAsk(prompt: Action<SDSContext, SDSEvent>, nomatch: string, help:string) : MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states:{\n            prompt: {\n                entry: prompt,\n                on: {ENDSPEECH: 'ask'}\n            },\n            ask: {\n                entry: [send('LISTEN'), send('MAXSPEECH', {delay: 4000, id: 'timeout'})],\n            },\n            nomatch: {\n                entry: say(nomatch),\n                on: { ENDSPEECH: \"prompt\" }\n            },\n            help: {\n                entry: say(help),\n                on: { ENDSPEECH: 'ask' }\n            }\n        }})}\n\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }            \n        },        \n\n        welcome: {\n            on: {\n                RECOGNISED: {\n                    target: \"query\",\n                    actions: assign((context) => { return { option: context.recResult } }),\n                }    \n            },\n                    ...promptAndAsk1(\"What would you like to do? Your options are appointment, to do item or timer\")\n        },\n\n        query: {\n            invoke: {\n                id: 'rasa',\n                src: (context, event) => nluRequest(context.option),\n                onDone: {\n                    target: 'menu',\n                    actions: [assign((context, event) => { return  {option: event.data.intent.name} }),\n                    (context: SDSContext, event: any) => console.log(event.data)]\n                },\n                onError: {\n                    target: 'welcome',\n                    actions: (context, event) => console.log(event.data)\n                }\n            }\n        },\n\n        menu: {\n            initial: \"prompt\",\n            on: {\n                ENDSPEECH: [\n                    { target: 'todo', cond: (context) => context.option === 'todo' },\n                    { target: 'timer', cond: (context) => context.option === 'timer' },\n                    { target: 'appointment', cond: (context) => context.option === 'appointment' }\n                ]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. I understand.`\n                    })),\n                }\n            }       \n        },\n\n        todo: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"init\" },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Let's create a to do item`\n                    }))\n                }}\n        },\n        \n        timer: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"init\" },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Let's create a timer`\n                    }))\n                }}\n        },\n        \n        maxspeech : {\n            entry: say(\"Sorry I couldn't hear anything\"),\n            on: {'ENDSPEECH': 'mainappointment.hist'}\n        },\n\n        finalmaxspeech: {\n            entry: say(\"It appears you are not there anymore. Goodbye.\"),\n            on: {'ENDSPEECH': 'init'}\n        },\n        \n        appointment: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"mainappointment\" },\n            states: {\n                prompt: { entry: say(\"Let's create an appointment\") }\n            }\n        },\n        \n        mainappointment: {\n            initial: 'who',\n            on: {\n                MAXSPEECH: [\n                    {cond: (context) => context.counter == 3, target: 'finalmaxspeech'},\n                    {target: 'maxspeech', actions: assign((context) => { count++; return { counter: count } })}\n                ]\n            },\n\n            states: {            \n                hist: { type: 'history', history: 'shallow' },\n\n                who: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [\n                            { cond: (context) => \"person\" in (grammar[context.recResult] || {}),\n                            actions: assign((context) => { return { person: grammar[context.recResult].person } }),\n                            target: \"day\" },\n                            { cond: (context) => (context.recResult in commands),\n                            target: \".help\" },\n                            { target: \".nomatch\" }\n                        ]\n                    },\n                ...promptAndAsk (say (\"Who are you meeting with?\"), \"Sorry, I don't know them\", \"You need to tell me which person you will be meeting so that I can set the appointment\")\n                },    \n\n                day: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [\n                            { cond: (context) => 'day' in (grammar[context.recResult] || {}),\n                            actions: assign((context) => { return { day: grammar[context.recResult].day } }),\n                            target: 'wholeday'},\n                            { cond: (context) => (context.recResult in commands), target: \".help\" },\n                            { target: \".nomatch\" }                \n                        ]\n                    },\n                    ...promptAndAsk (send((context) => ({ type: \"SPEAK\", value: `OK ${context.person}. On which day is your meeting?`})), \n                    \"Sorry, could you repeat that?\", \"I am asking what day your meeting will take place so that I can put it on your calendar\")\n                },\n\n                wholeday: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [\n                            { cond: (context) => (grammar2[context.recResult] === b), target: \"time\" },\n                            { cond: (context) => (grammar2[context.recResult] === a), target: \"confirmwholeday\" },\n                            { cond: (context) => (context.recResult in commands), target: \".help\" },\n                            { target: \".nomatch\" }               \n                        ]\n                    },\n                    ...promptAndAsk (send((context) => ({ type: \"SPEAK\", value: `OK ${context.day}. Will your meeting take the whole day?`})), \n                    \"Sorry, could you repeat that?\", \"I am asking whether your meeting will take the whole day so that I clear your schedule\")\n                },\n\n                time: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [\n                            { cond: (context) => \"time\" in (grammar[context.recResult] || {}),\n                            actions: assign((context) => { return { time: grammar[context.recResult].time } }),\n                            target: \"confirmtime\" },\n                            { cond: (context) => (context.recResult in commands), target: \".help\" },\n                            { target: \".nomatch\" } \n                        ]\n                    },\n                    ...promptAndAsk (send((context) => ({ type: \"SPEAK\", value: `OK ${context.day}. What time is your meeting?`})), \n                    \"Sorry, could you repeat that?\", \"I am asking what time you would like to schedule your meeting\")\n                },    \n\n                confirmwholeday: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [\n                            {cond: (context) => (grammar2[context.recResult] === b), target: \"who\" },\n                            {cond: (context) => (grammar2[context.recResult] === a), target: \"confirmed\" },\n                            { cond: (context) => (context.recResult in commands), target: \".help\" },\n                            { target: \".nomatch\" } \n                        ]\n                    },\n                    ...promptAndAsk (send((context) => ({ type: \"SPEAK\", value: `OK. Do you want to create an appointment with ${context.person} on ${context.day} for the whole day?`})), \n                    \"Sorry, could you repeat that?\", \"I am asking if you confirm the appointment I have created so I can put it on your schedule\")\n                },   \n\n                confirmtime: {\n                    initial: \"prompt\",\n                    on:  {\n                        RECOGNISED: [\n                            {cond: (context) => (grammar2[context.recResult] === b), target: \"who\" },\n                            {cond: (context) => (grammar2[context.recResult] === a), target: \"confirmed\" },\n                            { cond: (context) => (context.recResult in commands), target: \".help\" },\n                            { target: \".nomatch\" }                         \n                        ]\n                    },\n                    ...promptAndAsk (send((context) => ({ type: \"SPEAK\", value: `OK. Do you want to create an appointment with ${context.person} on ${context.day} at ${context.time}?`})), \n                    \"Sorry, could you repeat that?\", \"I am asking if you confirm the appointment I have created so I can put it on your schedule\")\n                },  \n\n                confirmed: {\n                    initial: \"prompt\",\n                    states: {\n                        prompt: {\n                            entry: send((context) => ({\n                                type: \"SPEAK\",\n                                value: `Your appointment has been created!` }))\n                        },\n                    }\n                }                 \n    } //states 2 closes\n    }, //MainAppointment closes   \n    }})\n\n\n\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://irenetsk.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'http://localhost:3000/react-xstate-colourchanger' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, send, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\n// import { dmMachine } from \"./dmSmartHome\";\nimport { dmMachine } from \"./dmAppointmentPlus2\";\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\n\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dmMachine\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    }\n                },\n                recognising: {\n\t\t            initial: 'progress',\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                        MAXSPEECH: 'idle',\n                    },\n                    states: {\n\t\t    \t        progress: {\n\t\t\t            },\t    \t\t\t\t\t\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive a color command.');\n                listen({\n                    interimResults: false,\n                    continuous: true\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            changeColour: asEffect((context) => {\n                console.log('Repainting...');\n                document.body.style.background = context.recResult;\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda })\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            })\n            /* speak: asEffect((context) => {\n\t     * console.log('Speaking...');\n             *     speak({text: context.ttsAgenda })\n             * } */\n        }\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\n\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://irenetsk.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'http://maraev.me' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);"],"sourceRoot":""}